#include <freertos/FreeRTOS.h>
#include <cmath>
#include <esp_log.h>
#include <driver/gpio.h>
#include <freertos/task.h>
#include <driver/ledc.h>
#include <esp_err.h>
#include <rom/ets_sys.h>

#include <driver/rmt_tx.h>
#include <driver/rmt_rx.h>
#include <hal/rmt_types.h>
#include <driver/rmt_common.h>
#include <driver/rmt_encoder.h>
#include <nvs_flash.h>

#include "sdkconfig.h" // generated by "make menuconfig"

#include "DHT22.h"
#include "SSD1366.h"
#include "comms/wifi.h"

#define MAX_PWM_DUTY 1023
#define SECONDS_UPDATE_DHT22 3

constexpr gpio_num_t LED_BUILTIN = GPIO_NUM_2;
constexpr gpio_num_t ORANGE_TEST = GPIO_NUM_13;
constexpr gpio_num_t PWM_GREEN_LED = GPIO_NUM_32;
constexpr gpio_num_t PWM_RED_LED = GPIO_NUM_12;
constexpr gpio_num_t DHT_GPIO = GPIO_NUM_14;
constexpr gpio_num_t SDA_GPIO = GPIO_NUM_21;
constexpr gpio_num_t SCL_GPIO = GPIO_NUM_22;


extern "C" void app_main();

int cnt = 0;
int dir = 1;
int b_aux[DATA_LENGTH]={};
int b_auxParsed[40]={};

DHT22 sensorTemp(DHT_GPIO);
SSD1366 oLed(SDA_GPIO, SCL_GPIO);

char oledStr[64];
int64_t timePassSensTemp = esp_timer_get_time();

void app_main(){

    //Setup
    //setup();

    //Config GPIO2 
    gpio_config_t config;
    config.mode = GPIO_MODE_OUTPUT;
    config.pin_bit_mask = (1<<LED_BUILTIN);
    config.intr_type = GPIO_INTR_DISABLE;
    config.pull_down_en = GPIO_PULLDOWN_DISABLE; 
    config.pull_up_en = GPIO_PULLUP_DISABLE;
    gpio_config(&config);

    ledc_timer_config_t ledcTimer = {
        .speed_mode       = LEDC_LOW_SPEED_MODE,
        .duty_resolution  = LEDC_TIMER_10_BIT,
        .timer_num        = LEDC_TIMER_0,
        .freq_hz          = 500,  // Set output frequency at 4 kHz
        .clk_cfg          = LEDC_AUTO_CLK,
        .deconfigure      = false
    };
    ESP_ERROR_CHECK(ledc_timer_config(&ledcTimer));

    ledc_channel_config_t ledcChannel;
    ledcChannel.channel = LEDC_CHANNEL_0;
    ledcChannel.gpio_num = PWM_GREEN_LED;
    ledcChannel.duty = 500;
    ledcChannel.timer_sel = LEDC_TIMER_0;
    ledcChannel.intr_type = LEDC_INTR_DISABLE;
    ledcChannel.hpoint = 0;
    ledcChannel.speed_mode = LEDC_LOW_SPEED_MODE;
    ledcChannel.flags.output_invert = 0;
    ESP_ERROR_CHECK(ledc_channel_config(&ledcChannel));


    ledcChannel.channel = LEDC_CHANNEL_1;
    ledcChannel.gpio_num = PWM_RED_LED;
    ESP_ERROR_CHECK(ledc_channel_config(&ledcChannel));





    //rmt_item32_t items[1];
    //items[0].duration0 = 3;
    //items[0].level0 = 1;
    //items[0].duration1 = 3;
    //items[0].level1 = 0;
    //items[0].duration0 = 0; //termination
    //items[0].level0 = 0;



    int64_t micros = esp_timer_get_time();


    //Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
      ESP_ERROR_CHECK(nvs_flash_erase());
      ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);



    //Loop
    while(1){
        //loop();
        
        //Poner el gpio2 a 3.3 , espera un tiempo y lo baja a 0
        /*gpio_set_level(LED_BUILTIN, 1);
        vTaskDelay(pdMS_TO_TICKS(500));
        gpio_set_level(LED_BUILTIN, 0);
        vTaskDelay(pdMS_TO_TICKS(500));

        //Prueba de log esp
        ESP_LOGE("hola", "datos");*/
        
        
        //PWM
        ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_1, (sensorTemp.humidity*2.5));
        ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_1);

        //gpio_set_level(ORANGE_TEST, 1);

        


        //DHT22 Sensor de temperatura y humedad

        // Actualizar cada 3 segundos
        if(((int)(esp_timer_get_time()-timePassSensTemp)) > SECONDS_UPDATE_DHT22*1000*1000){
            //printf("Tiempo entre lectura: %d\n", ((int)(esp_timer_get_time()-timePassSensTemp)));
            timePassSensTemp = esp_timer_get_time();
            

            
        }   
        
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}