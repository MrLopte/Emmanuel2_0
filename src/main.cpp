#include <freertos/FreeRTOS.h>
#include <cmath>
#include <esp_log.h>
#include <driver/gpio.h>
#include <driver/i2c.h>
#include <freertos/task.h>
#include <driver/ledc.h>
#include <esp_err.h>
#include <rom/ets_sys.h>

#include <driver/rmt_tx.h>
#include <driver/rmt_rx.h>
#include <hal/rmt_types.h>
#include <driver/rmt_common.h>
#include <driver/rmt_encoder.h>
#include <nvs_flash.h>

#include "sdkconfig.h" // generated by "make menuconfig"

#include "DHT22.h"
#include "SSD1366.h"
#include "comms/wifi.h"

//SENSOR HDC1080*********
#include "hdc1080.h"
#include "esp8266_wrapper.h"


//EINK SCREEN
#include <GxEPD2_BW.h>
#include <GxEPD2_3C.h>
#include <Fonts/FreeMonoBold9pt7b.h>
#define ENABLE_GxEPD2_GFX 0

#define MAX_PWM_DUTY 1023
#define SECONDS_UPDATE_DHT22 5

constexpr gpio_num_t LED_BUILTIN = GPIO_NUM_2;
constexpr gpio_num_t ORANGE_TEST = GPIO_NUM_13;
constexpr gpio_num_t PWM_GREEN_LED = GPIO_NUM_32;
constexpr gpio_num_t PWM_RED_LED = GPIO_NUM_12;
constexpr gpio_num_t DHT_GPIO = GPIO_NUM_14;
constexpr gpio_num_t SDA_GPIO = GPIO_NUM_21;
constexpr gpio_num_t SCL_GPIO = GPIO_NUM_22;


extern "C" void app_main();

//SENSOR HDC1080*********


// user task stack depth for ESP32
#define TASK_STACK_DEPTH 2048
// I2C interface defintions for ESP32 and ESP8266
#define I2C_BUS       0
#define I2C_FREQ      I2C_FREQ_100K

/* -- user tasks --------------------------------------------------- */

static hdc1080_sensor_t* sensor;
    float temperature;
    float humidity;

void user_task_periodic(void *pvParameters)
{
    float temperature;
    float humidity;

    TickType_t last_wakeup = xTaskGetTickCount();

    while (1)
    {

        // get the results and do something with them
        if (hdc1080_read(sensor, &temperature, &humidity))
            printf("%.3f HDC1080 Sensor periodic: temperature %.2f degrees, humidity %.2f\n",
                   (double)sdk_system_get_time()*1e-3, temperature, humidity);

        // passive waiting until 1 second is over
        vTaskDelayUntil(&last_wakeup, 1000 / portTICK_PERIOD_MS);
    }
}
//SENSOR HDC1080*********

//EINK SCREEN 
// 2.9'' EPD Module
GxEPD2_BW<GxEPD2_290_BS, GxEPD2_290_BS::HEIGHT> display(GxEPD2_290_BS(/*CS=5*/ 5, /*DC=*/ 0, /*RES=*/ 2, /*BUSY=*/ 15)); // DEPG0290BS 128x296, SSD1680

int cnt = 0;
int dir = 1;
int b_aux[DATA_LENGTH]={};
int b_auxParsed[40]={};

DHT22 sensorTemp(DHT_GPIO);
SSD1366 oLed(SDA_GPIO, SCL_GPIO);

char oledStr[64];
int64_t timePassSensTemp = esp_timer_get_time();

void app_main(){


    //Setup
    //setup();

    //Config GPIO2 
    gpio_config_t config;
    config.mode = GPIO_MODE_OUTPUT;
    config.pin_bit_mask = (1<<LED_BUILTIN);
    config.intr_type = GPIO_INTR_DISABLE;
    config.pull_down_en = GPIO_PULLDOWN_DISABLE; 
    config.pull_up_en = GPIO_PULLUP_DISABLE;
    gpio_config(&config);

    ledc_timer_config_t ledcTimer = {
        .speed_mode       = LEDC_LOW_SPEED_MODE,
        .duty_resolution  = LEDC_TIMER_10_BIT,
        .timer_num        = LEDC_TIMER_0,
        .freq_hz          = 500,  // Set output frequency at 4 kHz
        .clk_cfg          = LEDC_AUTO_CLK,
        .deconfigure      = false
    };
    ESP_ERROR_CHECK(ledc_timer_config(&ledcTimer));

    ledc_channel_config_t ledcChannel;
    ledcChannel.channel = LEDC_CHANNEL_0;
    ledcChannel.gpio_num = PWM_GREEN_LED;
    ledcChannel.duty = 500;
    ledcChannel.timer_sel = LEDC_TIMER_0;
    ledcChannel.intr_type = LEDC_INTR_DISABLE;
    ledcChannel.hpoint = 0;
    ledcChannel.speed_mode = LEDC_LOW_SPEED_MODE;
    ledcChannel.flags.output_invert = 0;
    ESP_ERROR_CHECK(ledc_channel_config(&ledcChannel));


    ledcChannel.channel = LEDC_CHANNEL_1;
    ledcChannel.gpio_num = PWM_RED_LED;
    ESP_ERROR_CHECK(ledc_channel_config(&ledcChannel));





    //rmt_item32_t items[1];
    //items[0].duration0 = 3;
    //items[0].level0 = 1;
    //items[0].duration1 = 3;
    //items[0].level1 = 0;
    //items[0].duration0 = 0; //termination
    //items[0].level0 = 0;



    int64_t micros = esp_timer_get_time();


    //Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
      ESP_ERROR_CHECK(nvs_flash_erase());
      ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    // init all I2C bus interfaces at which HDC1080 sensors are connected
    i2c_init (I2C_BUS, SCL_GPIO, SDA_GPIO, I2C_FREQ);
    // init the sensor with slave address HDC1080_I2C_ADDR connected I2C_BUS.
    sensor = hdc1080_init_sensor (I2C_BUS, HDC1080_ADDR);

    /*if (sensor)
    {
        printf("Initialized HDC1080 sensor: manufacurer %x, device id %x\n", hdc1080_get_manufacturer_id(sensor), hdc1080_get_device_id(sensor));
        // create a periodic task that uses the sensor
        xTaskCreate(user_task_periodic, "user_task_periodic", TASK_STACK_DEPTH, NULL, 2, NULL);

    }
    else
        printf("Could not initialize HDC1080 sensor\n");
*/
    //Loop
    while(1){
        //loop();
        
        //Poner el gpio2 a 3.3 , espera un tiempo y lo baja a 0
        /*gpio_set_level(LED_BUILTIN, 1);
        vTaskDelay(pdMS_TO_TICKS(500));
        gpio_set_level(LED_BUILTIN, 0);
        vTaskDelay(pdMS_TO_TICKS(500));

        //Prueba de log esp
        ESP_LOGE("hola", "datos");*/
        
        
        //PWM
        ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_1, (sensorTemp.humidity*2.5));
        ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_1);

        //gpio_set_level(ORANGE_TEST, 1);

        


        //DHT22 Sensor de temperatura y humedad

        // Actualizar cada 3 segundos
        if(((int)(esp_timer_get_time()-timePassSensTemp)) > SECONDS_UPDATE_DHT22*1000*1000){
            printf("Tiempo entre lectura: %d\n", ((int)(esp_timer_get_time()-timePassSensTemp)));
            timePassSensTemp = esp_timer_get_time();
            
             if (hdc1080_read(sensor, &temperature, &humidity))
            printf("%.3f HDC1080 Sensor periodic: temperature %.2f degrees, humidity %.2f\n",
                   (double)sdk_system_get_time()*1e-3, temperature, humidity);
            
        }   
        
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}